<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
<script>


const Lazyman = (() => {
  class Lazyman{
    constructor(name){
      // 一个空的贯穿全局的Promise
      this.queue = [];
      this.queue.push(this.makeP(`Hi, my name is ${name}`));
      setTimeout(() => {
        this.next();
      }, 0);
    }
    next(){
      const p = this.queue.shift();
      p && p().then(() => this.next());
    }
    // 这是一个Promise 里面包裹一个异步操作，在下一轮循环开始再加入队列，执行then的回调函数
    makeP(content, {time = 0} = {}){
      return () => new Promise(resolve => {
        setTimeout(() => {
          this.log(content);
          resolve();
        }, time * 1000);
      });
    }
    eat(food){
      this.queue.push(this.makeP(`Eat ${food}`));
      return this;
    }
    sleep(time){
      this.queue.push(this.makeP(`wakeup after ${time}s`, { time }));
      return this;
    }
    sleepFirst(time){
      this.queue.unshift(this.makeP(`FisrtSleep, wakeup after ${time}s`, { time }));
      return this;
    }
    log(content){
      console.log(content);
    }
  }

  return (name) => {
    return new Lazyman(name);
  };
})();


// Lazyman('鲍旭').sleep(3).eat('鱼香肉丝').eat('锅包肉').sleepFirst(2);
console.log('我是第一个循环里的输出');

const L = (() => {
  class Lazyman{
    constructor(name){
      this.queue = [];
      this.queue.push(this.makeP(`Hi, my name is ${name}`));
      setTimeout(this.seq.bind(this), 0);
    }
    // 这是一个Promise 里面包裹一个异步操作，在下一轮循环开始再加入队列，执行then的回调函数
    makeP(content, {time = 0} = {}){
      return () => new Promise(resolve => {
        setTimeout(() => {
          this.log(content);
          resolve();
        }, time * 1000);
      });
    }
    eat(food){
      this.queue.push(this.makeP(`大吉大利，今晚吃“${food}”`));
      return this;
    }
    sleep(time){
      this.queue.push(this.makeP(`wakeup after ${time}s`, { time }));
      return this;
    }
    sleepFirst(time){
      this.queue.unshift(this.makeP(`FisrtSleep, wakeup after ${time}s`, { time }));
      return this;
    }
    log(content){
      console.log(content);
    }
    async seq() {
      while(this.queue.length > 0){
        await this.queue.shift()();
      }
    }
  }

  return (name) => new Lazyman(name);

})(name);

L('大逃杀玩家').sleep(3).eat('鸡').eat('锅包肉').sleepFirst(2);
</script>
</body>
</html>
